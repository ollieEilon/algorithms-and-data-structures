/* In this file functions are defined for the construction of expression trees
 * from infix expressions generated by the grammar defined in recognizeExp.c:
 *
 * 
 * Starting pount is the token list obtained from the scanner (in scanner.c).
 */

#include <stdio.h>  /* printf */
#include <stdlib.h> /* malloc, free */
#include <assert.h> /* assert */
#include "scanner.h"
#include "recognizeExp.h"
#include "evalExp.h"
#include "prefixExp.h"
#include "infixExp.h"




ExpTree treeInfixExpression(List *lp, ExpTree *tp);

/* The function evalNumberOrBracket checks if the next list item is either a number, identifier or open bracket.
 * If it is a number or an identifier, it returns a leaf node with the given token.
 * If it is an open bracket, it runs treeInfixExpression again and than returns the tree enclosed by brackets as the node.
 */

ExpTree evalNumberOrBracket(List *lp){
 double w;
 char *s;
 Token t;
 ExpTree tT = NULL;
 if ( valueNumber(lp,&w) ) { 
    t.number = (int)w;
    tT = newExpTreeNode(Number, t, NULL, NULL);
 } else if ( valueIdentifier(lp,&s) ) {
    t.identifier = s;
    tT = newExpTreeNode(Identifier, t, NULL, NULL);
    return tT;
  } else if (acceptCharacter(lp,'(')) {
    tT = treeInfixExpression(lp,&tT);
  }
 return tT;
}

/* The function treeInfixExpression makes a tree that looks the same as the tree would look like in prefExp.c if it was written in prefix style.
 * This way, it complies with the other functions in prefExp. The function starts with a base tree of 3 nodes, and
 * depending on the operator, it will either (for +,-) make the root node the left child of the new operator with the
 * right child being the next evalNumberOrBracket, or (for *,/) it will make the right node the new operator, with the old
 * right node being the left child of that new node, and the right node being the next evalNumberOrBrackete.
 */

ExpTree treeInfixExpression(List *lp, ExpTree *tp) {
  char c;
  int dom = 0;
  Token t;
  ExpTree tC = NULL;
  ExpTree tL, tR;
  if (acceptCharacter(lp,')')) {
    return tC;
  }

  // making a base tree of 3 nodes
  tL = evalNumberOrBracket(lp);
  if (*lp == NULL || acceptCharacter(lp,')')) {
    return tL;
  }
  
  valueOperator(lp,&c);
  t.symbol = c;
  if (c == '+' || c == '-'){
    dom = 1;
  }
  tR = evalNumberOrBracket(lp);
  tC = newExpTreeNode(Symbol, t, tL, tR);

  if (acceptCharacter(lp,')')) {
    return tC;
  }
  
  while (valueOperator(lp,&c)) {
   switch (c) {
    case '+':
     tR = evalNumberOrBracket(lp);
     t.symbol = (char)'+';
     tL = tC;
     tC = newExpTreeNode(Symbol, t, tL, tR);
     dom = 1;
     break;
    case '-':
     tR = evalNumberOrBracket(lp);
     t.symbol = (char)'-';
     tL = tC;
     tC = newExpTreeNode(Symbol, t, tL, tR);
     dom = 1;
     break;
    case '*':
     if (dom == 0){
     tR = evalNumberOrBracket(lp);
     t.symbol = (char)'*';
     tL = tC;
     tC = newExpTreeNode(Symbol, t, tL, tR);
     } else {
      tR = evalNumberOrBracket(lp);
      t.symbol = (char)'*';
      tL = tC->right;
      tC->right = newExpTreeNode(Symbol, t, tL, tR);
     }
     break;
    case '/':
     if (dom == 0){
     tR = evalNumberOrBracket(lp);
     t.symbol = (char)'/';
     tL = tC;
     tC = newExpTreeNode(Symbol, t, tL, tR);
     } else {
      tR = evalNumberOrBracket(lp);
      t.symbol = (char)'/';
      tL = tC->right;
      tC->right = newExpTreeNode(Symbol, t, tL, tR);
     }
     break;
   }
   if (acceptCharacter(lp,')')) {
    return tC;
  }
  }
  return tC;
}

/* the function infExpTrees performs a dialogue with the user and uses recognizeExp.c to check
 * if it is a valid expression. If so, it prints the infix form. When it is a numerical infix
 * expression, its value is computed and printed.
 */
void infExpTrees() {
  char *ar;
  List tl, tl1;
  ExpTree t = NULL;
  printf("give an expression: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printList(tl);
    tl1 = tl;
    if (acceptExpression(&tl1) && tl1 == NULL ) {
      tl1 = tl;
      t = treeInfixExpression(&tl1,&t);
      printf("in infix notation: ");
      printExpTreeInfix(t);
      printf("\n");
      if ( isNumerical(t) ) {
        printf("the value is %g\n",valueExpTree(t));
      } else {
        printf("this is not a numerical expression\n");
      }
    } else {
      printf("this is not an expression\n");
    }
    freeExpTree(t);
    t = NULL;
    freeTokenList(tl);
    free(ar);
    printf("\ngive an expression: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}