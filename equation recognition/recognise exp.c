/* In this file a recognizer acceptExpression is definined that can recognize
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c).
 * For the recognition of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 */

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */ 
#include <string.h>
#include "scanner.h"
#include "recognizeExp.h"

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */
 
int recentIdentifierGlobal = 0;
int variableGlobal = 0;
int powerGlobal = 0;
int degreeGlobal = 1;

int countDegree(List lp){
  int max = 1;
  while (lp != NULL){
    if (lp -> tt == Symbol && lp->t.symbol == '^'){
      lp = lp -> next;
      if (lp->t.number > max ||( powerGlobal == 0 && lp->t.number == 0)){
        max = lp->t.number;
        powerGlobal++;
      }
    } 
    lp = lp -> next;  
  }
  degreeGlobal = max;
  
}

void countVariables(List lp){
  Token previousVar;
  while(lp != NULL){
    if (lp-> tt == Identifier && !variableGlobal){
      variableGlobal++;
      previousVar = lp->t;
    } else if (lp->tt == Identifier){
      if (strcmp(lp->t.identifier, previousVar.identifier)){
        variableGlobal++;   
        previousVar = lp->t;
      }
    }
    lp = lp->next;
  } 
}

void countVariables1(List li) {
  Token previousVar; 
  int currentDegree = 0;
  int degreeHasChanged = 0;
  while (li != NULL) {
    if (li->tt == Identifier && ! variableGlobal){
      variableGlobal++;
      previousVar = li ->t;
    } else if (!strcmp(li->t.identifier, previousVar.identifier)){
      previousVar = li -> t;
      variableGlobal++;
    }
    li = li->next;
    if (li != NULL) {
      if (variableGlobal < 2) {
        if ((li->t).symbol == '^'){
          li = li->next;
          if (li != NULL) {
            currentDegree = (li->t).number;
            if (degreeHasChanged == 0) {
              degreeGlobal = currentDegree;
              degreeHasChanged++;
            } else if (currentDegree > degreeGlobal) {
              degreeGlobal = currentDegree;
            }
          } else {
            return;
          }
        }
      }
    } else {
      return;
    }
    break;
  }
  li = li->next;
}


int acceptNumber(List *lp) {
  if (*lp != NULL && (*lp)->tt == Number) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptIdentifier(List *lp) {
  if (*lp != NULL && (*lp)->tt == Identifier) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptCharacter(List *lp, char c) {
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptFactor(List *lp) {
  return
    (  acceptNumber(lp)
    || acceptIdentifier(lp)
    || ( acceptCharacter(lp,'(')
       && acceptExpression(lp)
       && acceptCharacter(lp,')')
      )
    );
}


int acceptTerm(List *lp) {
  if (acceptNumber(lp)){
    if(acceptIdentifier(lp)){
      if(acceptCharacter(lp, '^')){
        if(acceptNumber(lp)){
          return 1;
        } else{
          return 0;
        }
      }
    } 
    return 1;
  } else if(acceptIdentifier(lp)){
    if(acceptCharacter(lp, '^')){
      if(acceptNumber(lp)){
        return 1;
      } else{
        return 0;
      }
    } else if(acceptNumber(lp)){
      return 0;
    }
    return 1;
  } else {return 0;}
}

int acceptExpression(List *lp) {

  if (acceptCharacter(lp, '-')) {
    if (!acceptTerm(lp)) {
      return 0;
    } 
  }else if (!acceptTerm(lp)) {
    return 0;
  }


  while (acceptCharacter(lp, '+') || acceptCharacter(lp, '-')) {
    if (!acceptTerm(lp)) {
      return 0;
    }
  } /* no + or -, so we reached the end of the expression */
  return 1;
}

int acceptEquation(List *lp) {
  return
    (acceptExpression(lp)
    && acceptCharacter(lp,'=')
    && acceptExpression(lp)
    );

}

/* The function recognizeExpressions demonstrates the recognizer. */
void recognizeExpressions() {
  char *ar;
  List tl, tl1;
  printf("give an equation: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    tl1 = tl;
    countVariables(tl);
    printList(tl1);
    countDegree(tl1);
    if (acceptEquation(&tl1) && tl1 == NULL ) {
      if (variableGlobal == 1){
        printf("this is an equation in 1 variable of degree %d\n",degreeGlobal);
      } else {
        printf("this is an equation, but not in 1 variable\n");
      }
    } else {
      printf("this is not an equation\n");
    }
    free(ar);
    freeTokenList(tl);
    printf("\ngive an equation: ");
    ar = readInput();
    recentIdentifierGlobal = 0;
    variableGlobal = 0;
    degreeGlobal = 1;
  }
  free(ar);
  printf("good bye\n");
}